---
title: "Numerical Data"
format: html
---


![Photo by <a href="https://unsplash.com/@markusspiske?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Markus Spiske</a> on <a href="https://unsplash.com/photos/8OyKWQgBsKQ?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>](media/markus-spiske-8OyKWQgBsKQ-unsplash.jpg)


## Numerical Data

By far, the most common kind of data we use in our analyses is numerical data. This may represent measured things like `height`, `snout-vent length` (whatever that is), `depth`, `age`, etc.  In data analysis, we commonly take (or obtain) measurements from several items and then try to characterize them using summaries and visualization.


As we go through this data type, we will follow the steps in the workflow as shown below.

<center>
![](media/workflow.png)
</center>


### Missing Data


All data types in `R`, including `numeric` types, can exist in a state of non-existence...  Missing data!  For all types it is represented as `NA` and can be assigned to a variable direclty.

```{r}
x <- NA
```

This is what it looks like when you ask to view the variable.

```{r}
x
```

And you can ask `R` if the data that the variable `x` is pointing to is missing as:

```{r}
is.na(x)
```

But by far, the most common way to get `NA` data in happens when you read in some data from an external source (say a CSV file) and there are empty elements.  In some cases, like ASC Raster representations, missing data (e.g., no data for this raster cell) is represented by an alternative value (commonly -9999 or some such other contrivance).  We will deal with that later, just be aware.


## Importing 


### Direct Input of Data 

In `R`, the numerical data type can be defined as:

```{r}
X <- 42
```

Notice how the numerical value of `42` is assigned to the variable named `X`.  In my mind, I see this and say to myself, "The variable capital X is assigned the value of 42."  You can also use the assignment operator `<-` in the other direction as 

```{r}
42 -> X
```

which is "The value of 42 is assigned to the variable capital X."  Both work the exact same way and there are times when one makes the code look more elegant and useful (a personal judgement statement by this author indeed), it does not impact the results.  


By default, you do not need to make a distinction between integers (e.g., counting numbers without fractional components) versus floating point data (e.g., things with a items to the right of the decimal).

To have `R` print out the value of a particular variable, you can type its name in the console and it will give it to you.

```{r}
X
```







::: {.callout-important}
### Case Sensitivity

All text evaluated in `R` is *case insensitive* meaning that `x` and `X` are totally different entities.  You will fall for this over and over again in your journey learning `R`.
:::

You can replace the value that the variable `X` is pointing at by reassigning a value over it.

```{r}
X <- 4
X
```


If you'd like to put in more than one value (as we commonly do), we **c**oncatenate it using the `c()` function.  

::: {.callout-note}
### Functions in `R`

In `R` a function is denoted by a name and a set of parentheses.  In the concatenate function, it is `c()` and the programmers who created `R` were generally lazy (as all programmers seek to be) so they shortened `concatenate` to just `c`.  The parentheses function to indicate to the `R` grammar parser that everything that is within the parentheses should be passed along to the function as input.  `R` is a functional programming language and we will see this design over an over again.
::: 

So, let's now make a vector of data and assign it to `X`:

```{r}
X <- c(4,3,6,2,9,8,1)
X
```


When we have a vector of data, it has *properties* such as:

```{r}
length(X)
```


### Introspection

Each item in `R` has a `class` (e.g., a defined type).  For the data we are talking about here, this is `numeric`.  Here is a singleton and vector of numeric types.

```{r}
# A single numeric value
y <- 42
y
# A vector of four numerical values
Y <- c(1,2,3,4)
Y
```

You can verify this by asking `R` what `class()` of information is contained in each variable:

```{r}
# Asking R what type of variables are contained in y and Y
class(y)
class(Y)
```

Later this will be a bit more informative when we start manipulating data.



### Indexing & Access

To access and change values within a vector, we used square brackets and the number of the entry of interest. It should be noted that in `R`, the first element of a vector is \# 1.

So, to get to the third element of the `x` vector, we would:

```{r}
X[3]
```

If you ask for values in the vector off the end (e.g., the index is beyond the length of the vector) it will return missing data.

```{r}
X[5]
```

In addition to getting the values from a vector, assignment of individual values proceeds similarily.

```{r}
X[2] <- 42
X
```

If you assign a value to a vector that is way off the end, it will fill in the intermediate values wtih `NA` for you.

```{r}
X[12] <- 43
X
```


### Sequences

There are many times that we need to get a sequence of values and there is a shorthand notation for this using a 'colon' notation. Here is an example showing a sequence of numbers from 1 to 10.

```{r}
idx <- 1:10
idx
```

We will return to this when we discuss slices below.




### Loading Data From External Sources

Rarely do we input data into our analyses by hand.  More commonly, we have a set of data locally or online that we import directly into `R`.  There are several ways to do this, but we are going to focus almost exclusively on a set of tools contained within an external library.  This library, `tidyverse` is actually a constellation of libraries that we will use so commonly, that you'll probably have it in every document and analysis we use in this course.  To load an external library, use use the `library()` function and pass it the name of the library we want like this:

```{r}
library( tidyverse )
```

You can see that it gives a bit of output that shows the individual packages that are loaded and some other verbiage associated with it (which we will learn how to suppress that later).

For this example, I'm going to load a CSV file that is contained on a GitHub account.  This file has data related to sample collected of the Sonoran Desert bark beetle, *Araptus attenuatus*, a species my laboratory has worked with in the past. These data consist of the location data from several locales take in Baja California.  To load these data, we need the URL to the CSV file.  This is represented by a quoted URL text (I'll show you how to save your data and make it available in your repository below).

```{r}
url <- "https://raw.githubusercontent.com/DyerlabTeaching/Data-Containers/main/data/arapat.csv"
```

Now, we need `R` to load these data into our current session using the `read_csv()` function (from `tidyverse`) and I'll pass the function the location.  If you have the file locally (on your computer), you would pass the relative path from your `R` file (quarto or R code) to the file instead of the url.

```{r}
beetles <- read_csv( url )
```

To see the contents of these data, we can just type the name of the variable as before:

```{r}
beetles
```

This is an output we have not yet seen before:

 1. There are several output columns of data. 
 2. Each column has the title of data variable (that are defined as the first row of the CSV file).  
 3. The whole output is paginated (e.g., you do not see it all on one printout, you can move Previous <-> Next to go through them).
 4. There is an indication of the size of the output at the top.  The `39 x 3` indicates that there is 39 rows of data and 3 columns. 
 
 This is a data container called a `data.frame`, and you can think of it like a spreadsheet.  This is made by the `read_csv()` function and is the `lingua franca` for almost all the work we will do in `R`.   The `data.frame` is a base `R` object and the `tidyverse` library adds functionality to it (behind the scenes) to make our lives easier.  We can ask `R` again what this object is as:

```{r}
class( beetles )
```

And it shows us that is is a `data.frame` but also a `tbl` (a 'tibble'... no really they called it a 'tibble'), a `tbl_df` and a `spec_tbl_df` (all of these are extensions to the basic tibble).  

As this is a representation of a spreadsheet, we need to recognize that:  

  1. Each row is a record.  
  2. Each record has one or more variables measured on it.  In the example above, it has a Stratum (denoted as a <chr> or character varibel), and both Longitude and Latitude variables (both are double numeric types).   
  3. Each column **must** have the exact same data types in the whole column (or missing entries) but each row may have many different types of records.  


#### New `data.frame` Objects

he `data.frame` is the most common container for all the data you'll be working with in `R`. It is *kind of* like a spreadsheet in that each column of data is the same kind of data measured on all objects (e.g., weight, survival, population, etc.) and each row represents one observation that has a bunch of different kinds of measurements associated with it.

Here is an example with three different data types (the z is a random sample of TRUE/FALSE equal in length to the other elements).

```{r}
x <- 1:10
y <- c(1,5,8,3,2,5,6,8,9,10.23)
```

I can put them into a `data.frame` object as:

```{r}
df <- data.frame( TheSequence = x,
                  Measurements = y )
df
```

Since each column is its own 'type' we can easily get a summary of the elements within it using `summary()`.

```{r}
summary( df )
```

And depending upon the data type, the output may give numerical, counts, or just description of the contents.

### Indexing

Just like a list, a `data.frame` can be defined as having named columns. The distinction here is that each column should have the same number of elements in it, whereas a list may have differnet lengths to the elements.

```{r}
names( df )
```


### Indexing

To get to components within a `data.frame`, we can use a couple of different approaches, including direct numeric indices that point to row indices and column indices.  We need to separte the row and column values by a comma and the order is *vital*.  Here is the entry in the first row and column of the `data.frame`.

```{r}
beetles[1,1]
```

We can also use the names of the data columns.  As it turns out the `data.frame` named `beetles` has three columns of data in it and we can use their names directly. 

```{r}
beetles$Longitude
```

Note, we use the dollar sign to separate the name of the `data.frame` from the vector of data

Here is the third entry in the longitude variable that we can use the square brackets to grab a value from it.

```{r}
beetles$Longitude[3]
```




### Slices

To get a slice of data from the `data.frame`, we can use the sequence operator.  Here we can grab the first 5 entries in `Stratum`.

```{r}
beetles$Stratum[1:5]
```

It also works in the reverse ( 5 $\to$ 1).

```{r}
beetles$Stratum[5:1]
```

We can use a shorthand to get all columns of data for certain rows by not providing any indices for the column.  Let's say we wanted the second, third, and fourth rows of data with all the columns.  This is returned by:

```{r}
beetles[2:4,]
```

Which returns a new `data.frame` with those three rows and all the columns (since you didn't specify any spceific ones).  It works the same way for all rows with specific columns

```{r}
beetles[ , 1:2 ]
```


A shorthand way to just get a glimpse of the data is to show the top (head) 

```{r}
head( beetles )
```


or bottom (tail) of the data.

```{r}
tail( beetles )
```

By default, it returns 6 rows but you can ask for a different number by passing an additional argument to the function.

```{r}
head( beetles, n = 3)
```

Look at the help file for the function head by typing `?head` to see some other options.  It is a good thing to get in the habit of looking at the help files for functions you are not familiar with.

![The head of the help file for the head function.  You can show this in RStudio by heading over to `?head` in the console.](media/Head_Help.png)

### Inspection of Data Frame Properties

When we load in data like this, we can easily get some kind of information about it (besides just printing it out as most of the time it will be **way** too big to display on your screen) by asking about its size.  A `data.frame` object consists of both row and columns, both of which constitute its dimensions.  In `R`, we can ask for these values as:

```{r}
nrow( beetles )
```

```{r}
ncol( beetles )
```

and for the dimensions as:

```{r}
dim(beetles)
```

which are always given as (row, col), just like the order we use to index components.  

We can also ask for the names of the columns using the `names()` function (when we have a ton of columns, getting this is very helpful).

```{r}
names( beetles )
```














## Transformations

Let's load in another data set, a much larger data set, to play around with as we begin to work on transformations.  This data set is from the [Rice Rivers Center](https://ricerivers.vcu.edu) and consists of measurements made on sets of atmospheric and aquatic conditions every five minutes.  

```{r}
url <- "https://docs.google.com/spreadsheets/d/1Mk1YGH9LqjF7drJE-td1G_JkdADOU0eMlrP01WFBT8s/pub?gid=0&single=true&output=csv"
```

This document exists as a Google Sheets document that is shared to the internet as a csv file from my google drive.  This is a great way to have a single location for data that can be accessed from your analyses without needing to replicate your data files all over the place.

We will load it in just like before (notice the extra information that is printed out with the more complicated data set).

```{r}
rice <- read_csv( url ) 
```


Before we look at it, let's see how big it is.

```{r}
dim( rice )
```

It has `r nrow(rice)` rows of data in it!  

Now, let's look at the names of the columns of the data.

```{r}
names( rice )
```

That is a lot of stuff.  But if you look at it, you can see some interesting things:

  1. Mixed Units:  I see °F and °C for temperature and `_in`, `_ft`, and `_m` for lengths.   
  2. Repetition:  Why do they have `Depth_ft`, `Depth_m`, and `SurfaceWaterElev_m_levelNad83m` as separate columns?  Isn't this redundant?  
  3. No Metadata:  Some of the column names are cryptic.  What is `Chla_ugl` ?  

This is a great example of how most data comes to you.  It is oddly formatted, often intended for purposes that are not aligned with what you are trying to do, and collected under conditions that may be orthogonal to *your* needs.  Most of the time that we work with data, the vast majority of the time is spent on configuring and conditioning it.




### Basic Mathematical Operations

For both single variables and vectors of variables in `R`, we can perform basic mathematical operations.  These include:




### Verbs of Manipulation






## Visualizing 


### Summary Output

```{r}
summary( beetles )
```



### Mapping 


```{r}
library( leaflet )
beetles %>%
  leaflet() %>%
  addProviderTiles(provider = providers$Esri.WorldTopo) %>%
  addMarkers( ~Longitude, ~Latitude,popup = ~Stratum )
```



## Communicating 




### Reproducability

1. Google Drive
2. GitHub

## Questions

If you have any questions for me specifically on this topic consider posting to the discussion board on [Canvas](https://canvas.vcu.edu).
